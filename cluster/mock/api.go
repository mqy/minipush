// Code generated by MockGen. DO NOT EDIT.
// Source: cluster/api.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	kafka "github.com/segmentio/kafka-go"

	proto "github.com/mqy/minipush/proto"
)

// MockIKafkaReader is a mock of IKafkaReader interface.
type MockIKafkaReader struct {
	ctrl     *gomock.Controller
	recorder *MockIKafkaReaderMockRecorder
}

// MockIKafkaReaderMockRecorder is the mock recorder for MockIKafkaReader.
type MockIKafkaReaderMockRecorder struct {
	mock *MockIKafkaReader
}

// NewMockIKafkaReader creates a new mock instance.
func NewMockIKafkaReader(ctrl *gomock.Controller) *MockIKafkaReader {
	mock := &MockIKafkaReader{ctrl: ctrl}
	mock.recorder = &MockIKafkaReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIKafkaReader) EXPECT() *MockIKafkaReaderMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIKafkaReader) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIKafkaReaderMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIKafkaReader)(nil).Close))
}

// CommitMessages mocks base method.
func (m *MockIKafkaReader) CommitMessages(arg0 context.Context, arg1 ...kafka.Message) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommitMessages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CommitMessages indicates an expected call of CommitMessages.
func (mr *MockIKafkaReaderMockRecorder) CommitMessages(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitMessages", reflect.TypeOf((*MockIKafkaReader)(nil).CommitMessages), varargs...)
}

// FetchMessage mocks base method.
func (m *MockIKafkaReader) FetchMessage(arg0 context.Context) (kafka.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchMessage", arg0)
	ret0, _ := ret[0].(kafka.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchMessage indicates an expected call of FetchMessage.
func (mr *MockIKafkaReaderMockRecorder) FetchMessage(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchMessage", reflect.TypeOf((*MockIKafkaReader)(nil).FetchMessage), arg0)
}

// MockIKafkaWriter is a mock of IKafkaWriter interface.
type MockIKafkaWriter struct {
	ctrl     *gomock.Controller
	recorder *MockIKafkaWriterMockRecorder
}

// MockIKafkaWriterMockRecorder is the mock recorder for MockIKafkaWriter.
type MockIKafkaWriterMockRecorder struct {
	mock *MockIKafkaWriter
}

// NewMockIKafkaWriter creates a new mock instance.
func NewMockIKafkaWriter(ctrl *gomock.Controller) *MockIKafkaWriter {
	mock := &MockIKafkaWriter{ctrl: ctrl}
	mock.recorder = &MockIKafkaWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIKafkaWriter) EXPECT() *MockIKafkaWriterMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIKafkaWriter) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIKafkaWriterMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIKafkaWriter)(nil).Close))
}

// WriteMessages mocks base method.
func (m *MockIKafkaWriter) WriteMessages(arg0 context.Context, arg1 ...kafka.Message) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteMessages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteMessages indicates an expected call of WriteMessages.
func (mr *MockIKafkaWriterMockRecorder) WriteMessages(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMessages", reflect.TypeOf((*MockIKafkaWriter)(nil).WriteMessages), varargs...)
}

// MockICluster is a mock of ICluster interface.
type MockICluster struct {
	ctrl     *gomock.Controller
	recorder *MockIClusterMockRecorder
}

// MockIClusterMockRecorder is the mock recorder for MockICluster.
type MockIClusterMockRecorder struct {
	mock *MockICluster
}

// NewMockICluster creates a new mock instance.
func NewMockICluster(ctrl *gomock.Controller) *MockICluster {
	mock := &MockICluster{ctrl: ctrl}
	mock.recorder = &MockIClusterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICluster) EXPECT() *MockIClusterMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockICluster) Run(ctx context.Context, stopNotifyCh chan<- struct{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Run", ctx, stopNotifyCh)
}

// Run indicates an expected call of Run.
func (mr *MockIClusterMockRecorder) Run(ctx, stopNotifyCh interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockICluster)(nil).Run), ctx, stopNotifyCh)
}

// MockIHub is a mock of IHub interface.
type MockIHub struct {
	ctrl     *gomock.Controller
	recorder *MockIHubMockRecorder
}

// MockIHubMockRecorder is the mock recorder for MockIHub.
type MockIHubMockRecorder struct {
	mock *MockIHub
}

// NewMockIHub creates a new mock instance.
func NewMockIHub(ctrl *gomock.Controller) *MockIHub {
	mock := &MockIHub{ctrl: ctrl}
	mock.recorder = &MockIHubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIHub) EXPECT() *MockIHubMockRecorder {
	return m.recorder
}

// Kickoff mocks base method.
func (m *MockIHub) Kickoff(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Kickoff", arg0)
}

// Kickoff indicates an expected call of Kickoff.
func (mr *MockIHubMockRecorder) Kickoff(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Kickoff", reflect.TypeOf((*MockIHub)(nil).Kickoff), arg0)
}

// Offline mocks base method.
func (m *MockIHub) Offline() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Offline")
}

// Offline indicates an expected call of Offline.
func (mr *MockIHubMockRecorder) Offline() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Offline", reflect.TypeOf((*MockIHub)(nil).Offline))
}

// Online mocks base method.
func (m *MockIHub) Online() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Online")
}

// Online indicates an expected call of Online.
func (mr *MockIHubMockRecorder) Online() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Online", reflect.TypeOf((*MockIHub)(nil).Online))
}

// Run mocks base method.
func (m *MockIHub) Run(arg0 context.Context, arg1 chan<- *proto.FollowerMsg, arg2 <-chan *proto.LeaderMsg, arg3 chan<- struct{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Run", arg0, arg1, arg2, arg3)
}

// Run indicates an expected call of Run.
func (mr *MockIHubMockRecorder) Run(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockIHub)(nil).Run), arg0, arg1, arg2, arg3)
}
